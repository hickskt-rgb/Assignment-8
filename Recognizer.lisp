;;;; Recognizer.lisp
;;;; Recursive descent parser for validating token sequences

(load "Common.lisp")

;;; Global parser state
(defvar *tokens* nil)           ; List of all lex structures
(defvar *current-index* 0)      ; Index of current token being examined
(defvar *output-stream* nil)    ; Output file stream for error messages

;;; Define a custom condition for parse errors
(define-condition parse-error-condition (error)
  ((message :initarg :message :reader error-message)
   (is-nonterminal-error :initarg :is-nonterminal-error :reader is-nonterminal-error :initform nil)))

;;; Main recognizer function
(defun recognize-file (input-file output-file)
  "Parse tokens from input file and validate against grammar"
  (setf *tokens* (read-tokens-from-file input-file))
  (setf *current-index* 0)
  
  (with-open-file (stream output-file
                          :direction :output
                          :if-exists :supersede
                          :if-does-not-exist :create)
    (setf *output-stream* stream)
    
    ;; Parse starting from top-level grammar rule
    (handler-case
        (progn
          (parse-function)
          
          ;; Check that all tokens were consumed
          (when (< *current-index* (length *tokens*))
            (report-error (format nil "Only consumed ~D of the ~D given tokens"
                                 *current-index*
                                 (length *tokens*))))
          
          ;; If we get here, parsing succeeded
          (format stream "PARSED!!!~%"))
      (parse-error-condition (e)
        (format stream "~A~%" (error-message e))
        (force-output stream)))))

;;; Read tokens from file generated by Tokenizer
(defun read-tokens-from-file (filepath)
  "Read token and lexeme pairs from file into list of lex structures"
  (with-open-file (stream filepath :direction :input)
    (loop for line = (read-line stream nil)
          while line
          collect (parse-token-line line))))

;;; Parse a single line of token output (format: "TOKEN_TYPE lexeme")
(defun parse-token-line (line)
  "Parse a line like 'VARTYPE int' into a lex structure"
  (let* ((space-pos (position #\Space line))
         (token-str (subseq line 0 space-pos))
         (lexeme (subseq line (1+ space-pos))))
    (make-lex :token (intern (substitute #\- #\_ token-str) :keyword)
              :lexeme lexeme)))

;;; Report error by signaling a condition
(defun report-error (message &optional is-nonterminal)
  "Signal a parse error with the given message"
  (error 'parse-error-condition 
         :message (format nil "Error: ~A" message)
         :is-nonterminal-error is-nonterminal))

;;; Get current token without consuming it (lookahead)
(defun peek-token ()
  "Return current token type without advancing, or NIL if at end"
  (if (< *current-index* (length *tokens*))
      (lex-token (nth *current-index* *tokens*))
      nil))

;;; Get current token number (1-indexed for error messages)
(defun current-token-number ()
  "Return current token number (1-indexed)"
  (1+ *current-index*))

;;; Consume current token if it matches expected type
(defun match-token (expected-token rule-name)
  "Consume token if it matches expected type, otherwise report error"
  (let ((actual-token (peek-token)))
    (if (eq actual-token expected-token)
        (progn
          (incf *current-index*)
          t)
        (report-error 
         (format nil "In grammar rule ~A, expected token #~D to be ~A but was ~A"
                 rule-name
                 (current-token-number)
                 (token-to-string expected-token)
                 (if actual-token 
                     (token-to-string actual-token)
                     "EOF"))))))

;;; Check if current token matches any in a list
(defun token-in-list-p (token-list)
  "Return T if current token is in the given list"
  (member (peek-token) token-list))

;;; Grammar rule: function --> header body
(defun parse-function ()
  "Parse a function declaration"
  ;; Save current position to detect if header made progress
  (let ((start-pos *current-index*))
    (handler-case
        (parse-header)
      (parse-error-condition (e)
        ;; Only wrap as non-terminal error if we haven't consumed any tokens
        ;; (meaning the header rule itself never started successfully)
        (if (= *current-index* start-pos)
            (report-error "In grammar rule function, expected a valid header non-terminal to be present but was not" t)
            ;; Otherwise re-signal the original error (it's from within header)
            (error e)))))
  
  ;; For body, we don't wrap errors because body can fail in many ways
  ;; and those specific errors should be preserved
  (parse-body))

;;; Grammar rule: header --> VARTYPE IDENTIFIER LEFT_PARENTHESIS [arg-decl] RIGHT_PARENTHESIS
(defun parse-header ()
  "Parse function header"
  (match-token :VARTYPE "header")
  (match-token :IDENTIFIER "header")
  (match-token :LEFT-PARENTHESIS "header")
  
  ;; Optional arg-decl (starts with VARTYPE)
  (when (eq (peek-token) :VARTYPE)
    (parse-arg-decl))
  
  (match-token :RIGHT-PARENTHESIS "header"))

;;; Grammar rule: arg-decl --> VARTYPE IDENTIFIER {COMMA VARTYPE IDENTIFIER}
(defun parse-arg-decl ()
  "Parse argument declaration list"
  (match-token :VARTYPE "arg-decl")
  (match-token :IDENTIFIER "arg-decl")
  
  ;; Zero or more additional arguments
  (loop while (eq (peek-token) :COMMA) do
    (match-token :COMMA "arg-decl")
    (match-token :VARTYPE "arg-decl")
    (match-token :IDENTIFIER "arg-decl")))

;;; Grammar rule: body --> LEFT_BRACKET [statement-list] RIGHT_BRACKET
(defun parse-body ()
  "Parse function body"
  (match-token :LEFT-BRACKET "body")
  
  ;; Optional statement-list (starts with WHILE, RETURN, or IDENTIFIER)
  (when (token-in-list-p '(:WHILE-KEYWORD :RETURN-KEYWORD :IDENTIFIER))
    (parse-statement-list))
  
  (match-token :RIGHT-BRACKET "body"))

;;; Grammar rule: statement-list --> statement {statement}
(defun parse-statement-list ()
  "Parse list of statements"
  (parse-statement)
  
  ;; Zero or more additional statements
  (loop while (token-in-list-p '(:WHILE-KEYWORD :RETURN-KEYWORD :IDENTIFIER)) do
    (parse-statement)))

;;; Grammar rule: statement --> while-loop | return | assignment
(defun parse-statement ()
  "Parse a single statement"
  (cond
    ((eq (peek-token) :WHILE-KEYWORD)
     (parse-while-loop))
    
    ((eq (peek-token) :RETURN-KEYWORD)
     (parse-return))
    
    ((eq (peek-token) :IDENTIFIER)
     (parse-assignment))
    
    (t
     (report-error "In grammar rule statement, expected a valid statement to be present but was not."))))

;;; Grammar rule: while-loop --> WHILE_KEYWORD LEFT_PARENTHESIS expression RIGHT_PARENTHESIS body
(defun parse-while-loop ()
  "Parse while loop"
  (match-token :WHILE-KEYWORD "while-loop")
  (match-token :LEFT-PARENTHESIS "while-loop")
  
  ;; Save position before trying to parse expression
  (let ((expr-start *current-index*))
    (handler-case
        (parse-expression)
      (parse-error-condition (e)
        ;; Only wrap as non-terminal error if expression never started
        (if (= *current-index* expr-start)
            (report-error "In grammar rule while-loop, expected a valid expression non-terminal to be present but was not" t)
            ;; Otherwise re-signal the original error
            (error e)))))
  
  (match-token :RIGHT-PARENTHESIS "while-loop")
  (parse-body))

;;; Grammar rule: return --> RETURN_KEYWORD expression EOL
(defun parse-return ()
  "Parse return statement"
  (match-token :RETURN-KEYWORD "return")
  
  ;; Save position before trying to parse expression
  (let ((expr-start *current-index*))
    (handler-case
        (parse-expression)
      (parse-error-condition (e)
        ;; Only wrap as non-terminal error if expression never started
        (if (= *current-index* expr-start)
            (report-error "In grammar rule return, expected a valid expression non-terminal to be present but was not" t)
            ;; Otherwise re-signal the original error
            (error e)))))
  
  (match-token :EOL "return"))

;;; Grammar rule: assignment --> IDENTIFIER EQUAL expression EOL
(defun parse-assignment ()
  "Parse assignment statement"
  (match-token :IDENTIFIER "assignment")
  (match-token :EQUAL "assignment")
  
  ;; Save position before trying to parse expression
  (let ((expr-start *current-index*))
    (handler-case
        (parse-expression)
      (parse-error-condition (e)
        ;; Only wrap as non-terminal error if expression never started
        (if (= *current-index* expr-start)
            (report-error "In grammar rule assignment, expected a valid expression non-terminal to be present but was not" t)
            ;; Otherwise re-signal the original error
            (error e)))))
  
  (match-token :EOL "assignment"))

;;; Grammar rule: expression --> term {BINOP term} | LEFT_PARENTHESIS expression RIGHT_PARENTHESIS
;;; Note: The grammar allows for parenthesized expressions OR term sequences with BINOP
;;; A parenthesized expression is a complete expression unit
(defun parse-expression ()
  "Parse expression"
  (cond
    ;; Parenthesized expression
    ((eq (peek-token) :LEFT-PARENTHESIS)
     (match-token :LEFT-PARENTHESIS "expression")
     (parse-expression)
     (match-token :RIGHT-PARENTHESIS "expression")
     ;; After a parenthesized expression, check for BINOP term continuations
     (loop while (eq (peek-token) :BINOP) do
       (match-token :BINOP "expression")
       ;; The next part can be another term or parenthesized expression
       (if (eq (peek-token) :LEFT-PARENTHESIS)
           (progn
             (match-token :LEFT-PARENTHESIS "expression")
             (parse-expression)
             (match-token :RIGHT-PARENTHESIS "expression"))
           (parse-term))))
    
    ;; Term-based expression
    ((token-in-list-p '(:IDENTIFIER :NUMBER))
     (parse-term)
     ;; Zero or more BINOP term pairs
     (loop while (eq (peek-token) :BINOP) do
       (match-token :BINOP "expression")
       ;; The next part can be a term or parenthesized expression
       (if (eq (peek-token) :LEFT-PARENTHESIS)
           (progn
             (match-token :LEFT-PARENTHESIS "expression")
             (parse-expression)
             (match-token :RIGHT-PARENTHESIS "expression"))
           (parse-term))))
    
    (t
     (report-error "In grammar rule expression, expected a valid expression to be present but was not."))))

;;; Grammar rule: term --> IDENTIFIER | NUMBER
(defun parse-term ()
  "Parse term"
  (cond
    ((eq (peek-token) :IDENTIFIER)
     (match-token :IDENTIFIER "term"))
    
    ((eq (peek-token) :NUMBER)
     (match-token :NUMBER "term"))
    
    (t
     (report-error "In grammar rule term, expected a valid term to be present but was not."))))

;;; Entry point - parse command line arguments and run recognizer
(defun main ()
  "Main entry point for recognizer program"
  (let ((args sb-ext:*posix-argv*))  ; For SBCL
    (when (< (length args) 3)
      (format *error-output* "Usage: ~A <input-file> <output-file>~%" (first args))
      (sb-ext:exit :code 1))
    
    (let ((input-file (second args))
          (output-file (third args)))
      (recognize-file input-file output-file))))

;;; Run main function
(main)
